Problema I
En teoría y laboratorio hemos visto el lenguaje FAE, que es un lenguaje con expresiones aritméticas, funciones y
aplicaciones de funciones. ¿Es FAE un lenguaje Turing-Completo?. Debes proveer una respuesta breve e inambigua,
seguida de una justificación  mas extensa de tu respuesta. Hint: Investiguen sobre el combinador Y





Problema II
¿Java es glotón o perezoso? Escribe un programa para determinar la respuesta a esta pregunta. El mismo programa,
ejecutado en cada uno de los dos regímenes, debe producir resultados distintos. Puedes usar todas las características de Java
que gustes, pero debes mantener el programa relativamente corto: penalizaremos cualquier programa que consideremos
excesivamente largo o confuso (Hint: es posible resolver este problema con un programa de unas cuantas docenas de lineas).
Debes anexar tanto el código fuente de tu programa (en un archivo aparte al PDF de la tarea) asi como una respuesta a la
pregunta de si Java es glotón o perezoso, y una explicación de porque su programa determina esto.
Es decir, deben proveer una respuesta breve e inambigua (p.ej. ”Java es perezoso”) seguida de una descripción del resultado
que obtendrías bajo cada régimen, junto con una breve explicación de por que ese régimen generaría tal resultad








Problema III
En nuestro intérprete perezoso, identificamos 3 puntos en el lenguaje donde necesitamos forzar la evaluación de las 
expresiones closures (invocando a la función strict): la posición de la función de una aplicación, la expresión de prueba de 
una condicional, y las primitivas aritméticas. Doug Oord, un estudiante algo sedentario, sugiere que podemos reducir la 
cantidad de código reemplazando todas las invocaciones de strict por una sola. En el intérprete visto en el capítulo 8 del
libro de Shriram elimino todas las instancias de strict y reemplazo

[id (v) (lookup v env)]
por
[id (v) (strict (lookup v env))]

El razonamiento de Doug es que el único momento en que el intérprete regresa una expresión closure es cuando busca un 
identificador en el ambiente. Si forzamos esta evaluación, podemos estar seguros de que en ninguna otra parte del intérprete
tendremos un closure de expresiones, y eliminando las otras invocaciones de strict no causaremos ningún daño. Doug evita 
razonar en la otra dirección, es decir si esto resultara o no en un intérprete más glotón de lo necesario.






Problema IV
Ningún lenguaje perezoso en la historia ha tenido operaciones de estado (tales como la mutación de valores en cajas o
asignación de valores a variables) ¿Por que no?
La mejor respuesta a esta pregunta incluiría dos cosas: un pequeño programa (que asume la evaluación perezosa) el cual usara
estado y una breve explicación de cual es el problema que ilustra la ejecución de dicho programa. Por favor usa la noción
original (sin cache) de perezosos sin cambio alguno. Si presentas un ejemplo lo suficientemente ilustrativo (el cual no
necesita ser muy largo), tu explicación sera muy pequeña.
